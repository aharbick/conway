#!/usr/bin/env python3
import argparse
import os
import sys

def get_header(grid_size, topology):
    """Generate appropriate RLE header based on grid size and topology."""
    if grid_size == 7:
        width, height = 7, 7
    else:  # 8x8
        width, height = 8, 8

    # P for plane (non-wrapping), T for torus (wrapping)
    topo = "T" if topology == "torus" else "P"

    return [
        f"x = {width}, y = {height}, rule = B3/S23:{topo}{width},{height}"
    ]

def rle_to_bin(rle_lines, grid_size):
    """Convert RLE body (list of row strings) into a flattened binary string."""
    rows = []
    for line in rle_lines:
        row = []
        i = 0
        while i < len(line):
            if line[i].isdigit():
                j = i
                while j < len(line) and line[j].isdigit():
                    j += 1
                count = int(line[i:j])
                if j >= len(line):
                    break
                char = line[j]
                if char == 'o':
                    row.extend('1' * count)
                elif char == 'b':
                    row.extend('0' * count)
                i = j + 1
            elif line[i] == 'o':
                row.append('1'); i += 1
            elif line[i] == 'b':
                row.append('0'); i += 1
            elif line[i] in ('$','!'):
                i += 1
            else:
                i += 1
        # pad/truncate to width
        row = (row + ['0'] * grid_size)[:grid_size]
        rows.append("".join(row))

    # pad/truncate to exactly grid_size rows
    rows = (rows + ["0" * grid_size] * grid_size)[:grid_size]

    # Return row-major binary string
    return "".join(rows)

def bin_to_rle(binstring, grid_size):
    """Convert a binary string into compact RLE (no trailing 'b' on rows)."""
    expected_bits = grid_size * grid_size
    if len(binstring) != expected_bits or any(c not in '01' for c in binstring):
        raise ValueError(f"Binary string must be exactly {expected_bits} characters of 0/1 ({grid_size}x{grid_size}).")

    # The C++ asBinary() outputs MSB-first
    # For 7x7: bit 48 is at string index 0, bit 0 is at string index 48
    # Bit layout: row0[bits 0-6] row1[bits 7-13] ... row6[bits 42-48]
    # C++ outputs: [bit48...bit42][bit41...bit35]...[bit6...bit0]
    # Which is: [row6_reversed][row5_reversed]...[row0_reversed]

    # First reverse entire string to get rows in correct order
    binstring = binstring[::-1]
    # Now we have: [row0_reversed][row1_reversed]...[row6_reversed]

    # Split into rows and reverse each row to get correct bit order within each row
    rows = []
    for i in range(grid_size):
        row = binstring[i*grid_size:(i+1)*grid_size]
        rows.append(row[::-1])  # Reverse each row to get correct left-to-right order

    # Reverse the rows list so row0 comes first in the RLE output
    rows.reverse()

    rle_rows = []
    for row in rows:
        # Trim trailing zeros so we don't emit trailing 'b' runs
        last_one = row.rfind('1')
        if last_one == -1:
            # Entire row is blank → empty line; the '$' separator will represent it
            rle_rows.append("")
            continue

        segment = row[:last_one+1]
        out = []
        i = 0
        while i < len(segment):
            ch = segment[i]
            j = i
            while j < len(segment) and segment[j] == ch:
                j += 1
            runlen = j - i
            if runlen > 1:
                out.append(str(runlen))
            out.append('o' if ch == '1' else 'b')
            i = j
        rle_rows.append("".join(out))

    # Remove leading empty rows (blank rows at the start)
    while rle_rows and rle_rows[0] == "":
        rle_rows.pop(0)

    # Remove trailing empty rows to avoid ending with $!
    while rle_rows and rle_rows[-1] == "":
        rle_rows.pop()

    return "$".join(rle_rows) + "!"

def main():
    parser = argparse.ArgumentParser(description="Convert between RLE files, binary strings, and integers.")
    parser.add_argument("-i", "--input", help="Path to RLE file to read")
    parser.add_argument("-o", "--output", help="Path to RLE file to write")
    parser.add_argument("-b", "--binary", help="Binary string (49 chars for 7x7, 64 chars for 8x8)")
    parser.add_argument("-p", "--pattern", help="Integer pattern value")
    parser.add_argument("-g", "--grid-size", type=int, choices=[7, 8], default=8,
                        help="Grid size: 7 for 7x7, 8 for 8x8 (default: 8)")
    parser.add_argument("-t", "--topology", choices=["plane", "torus"], default="plane",
                        help="Topology: plane (non-wrapping) or torus (wrapping) (default: plane)")
    args = parser.parse_args()

    grid_size = args.grid_size
    expected_bits = grid_size * grid_size
    max_value = 2**expected_bits - 1

    binstring = None

    # Determine the input source
    if args.input:
        # Read RLE file → binary string
        if not os.path.exists(args.input):
            print(f"Error: file {args.input} does not exist", file=sys.stderr)
            sys.exit(1)
        with open(args.input) as f:
            lines = f.read().splitlines()

        # Ignore the two header lines
        body_lines = []
        for line in lines:
            if line.startswith("#") or line.startswith("x ="):
                continue
            body_lines.append(line)

        # Collapse to rows by splitting on '$' (ignore trailing '!')
        rle_str = "".join(body_lines).replace("!", "")
        rle_rows = rle_str.split("$") if rle_str else []
        binstring = rle_to_bin(rle_rows, grid_size)

        # Show both formats
        pattern_int = int(binstring, 2)
        print(f"Binary: {binstring}")
        print(f"Integer: {pattern_int}")

    elif args.pattern:
        # Integer → binary string
        pattern_int = int(args.pattern)
        if pattern_int < 0 or pattern_int > max_value:
            print(f"Error: pattern must be a {expected_bits}-bit unsigned integer (0 to {max_value})", file=sys.stderr)
            sys.exit(1)
        binstring = format(pattern_int, f'0{expected_bits}b')
        print(f"Binary: {binstring}")

    elif args.binary:
        # Binary string → integer
        if len(args.binary) != expected_bits or any(c not in '01' for c in args.binary):
            print(f"Error: binary string must be exactly {expected_bits} characters of 0/1 for {grid_size}x{grid_size} grid", file=sys.stderr)
            sys.exit(1)
        binstring = args.binary
        pattern_int = int(binstring, 2)
        print(f"Integer: {pattern_int}")

    else:
        print("Error: must specify one of -i, -p, or -b", file=sys.stderr)
        parser.print_help()
        sys.exit(1)

    # Write output RLE file if requested
    if args.output and binstring:
        rle_body = bin_to_rle(binstring, grid_size)
        header = get_header(grid_size, args.topology)
        with open(args.output, "w") as f:
            f.write("\n".join(header) + "\n")
            f.write(rle_body + "\n")
        print(f"Wrote RLE file to {args.output}")

if __name__ == "__main__":
    main()
