#!/usr/bin/env python3
import argparse
import os
import sys

HEADER = [
    "#CXRLE Pos=-4,-4",
    "x = 8, y = 8, rule = B3/S23:P8,8"
]

def rle_to_bin(rle_lines):
    """Convert RLE body (list of row strings) into a flattened 64-bit binary string."""
    rows = []
    for line in rle_lines:
        row = []
        i = 0
        while i < len(line):
            if line[i].isdigit():
                j = i
                while j < len(line) and line[j].isdigit():
                    j += 1
                count = int(line[i:j])
                if j >= len(line):
                    break
                char = line[j]
                if char == 'o':
                    row.extend('1' * count)
                elif char == 'b':
                    row.extend('0' * count)
                i = j + 1
            elif line[i] == 'o':
                row.append('1'); i += 1
            elif line[i] == 'b':
                row.append('0'); i += 1
            elif line[i] in ('$','!'):
                i += 1
            else:
                i += 1
        # pad/truncate to width 8
        row = (row + ['0'] * 8)[:8]
        rows.append("".join(row))
    # pad/truncate to exactly 8 rows
    rows = (rows + ["0"*8]*8)[:8]
    return "".join(rows)

def bin_to_rle(binstring):
    """Convert a 64-bit binary string (8x8) into compact RLE (no trailing 'b' on rows)."""
    if len(binstring) != 64 or any(c not in '01' for c in binstring):
        raise ValueError("Binary string must be exactly 64 characters of 0/1 (8x8).")

    rows = [binstring[i*8:(i+1)*8] for i in range(8)]
    rle_rows = []
    for row in rows:
        # Trim trailing zeros so we don't emit trailing 'b' runs
        last_one = row.rfind('1')
        if last_one == -1:
            # Entire row is blank → empty line; the '$' separator will represent it
            rle_rows.append("")
            continue

        segment = row[:last_one+1]
        out = []
        i = 0
        while i < len(segment):
            ch = segment[i]
            j = i
            while j < len(segment) and segment[j] == ch:
                j += 1
            runlen = j - i
            if runlen > 1:
                out.append(str(runlen))
            out.append('o' if ch == '1' else 'b')
            i = j
        rle_rows.append("".join(out))

    return "$".join(rle_rows) + "!"

def main():
    parser = argparse.ArgumentParser(description="Convert between RLE files, binary strings, and integers (8x8).")
    parser.add_argument("-i", "--input", help="Path to RLE file to read")
    parser.add_argument("-o", "--output", help="Path to RLE file to write")
    parser.add_argument("-b", "--binary", help="64-character binary string (0s and 1s)")
    parser.add_argument("-p", "--pattern", help="64-bit integer pattern value")
    args = parser.parse_args()

    binstring = None

    # Determine the input source
    if args.input:
        # Read RLE file → binary string
        if not os.path.exists(args.input):
            print(f"Error: file {args.input} does not exist", file=sys.stderr)
            sys.exit(1)
        with open(args.input) as f:
            lines = f.read().splitlines()

        # Ignore the two header lines
        body_lines = []
        for line in lines:
            if line.startswith("#") or line.startswith("x ="):
                continue
            body_lines.append(line)

        # Collapse to rows by splitting on '$' (ignore trailing '!')
        rle_str = "".join(body_lines).replace("!", "")
        rle_rows = rle_str.split("$") if rle_str else []
        binstring = rle_to_bin(rle_rows)

        # Show both formats
        pattern_int = int(binstring, 2)
        print(f"Binary: {binstring}")
        print(f"Integer: {pattern_int}")

    elif args.pattern:
        # Integer → binary string
        pattern_int = int(args.pattern)
        if pattern_int < 0 or pattern_int >= 2**64:
            print(f"Error: pattern must be a 64-bit unsigned integer (0 to {2**64-1})", file=sys.stderr)
            sys.exit(1)
        binstring = format(pattern_int, '064b')
        print(f"Binary: {binstring}")

    elif args.binary:
        # Binary string → integer
        if len(args.binary) != 64 or any(c not in '01' for c in args.binary):
            print("Error: binary string must be exactly 64 characters of 0/1", file=sys.stderr)
            sys.exit(1)
        binstring = args.binary
        pattern_int = int(binstring, 2)
        print(f"Integer: {pattern_int}")

    else:
        print("Error: must specify one of -i, -p, or -b", file=sys.stderr)
        parser.print_help()
        sys.exit(1)

    # Write output RLE file if requested
    if args.output and binstring:
        rle_body = bin_to_rle(binstring)
        with open(args.output, "w") as f:
            f.write("\n".join(HEADER) + "\n")
            f.write(rle_body + "\n")
        print(f"Wrote RLE file to {args.output}")

if __name__ == "__main__":
    main()
